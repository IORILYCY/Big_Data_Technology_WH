# 查询优化

* 性能下降 SQL 慢、执行时间长、等待时间长
  * 数据过多：分库分表
  * 关联了太多的表，太多 join：SQL 优化
  * 没有充分利用到索引：索引建立
  * 服务器调优及各个参数设置：调整 my.cnf

## 五、show profile

* mysql 提供的可以用来分析当前会话中 sql 语句执行的资源消耗情况的工具，可用于 sql 调优的测量
* 默认情况下处于关闭状态，保存最近15次的运行结果

```sql
-- 开启profile
set profiling = on;
-- 查看已存储的查询结果
show profiles;
-- 使用show profile对sql语句进行诊断
show profile cpu,block io for query Query_ID; -- Query_ID为上一步骤中show profiles结果列表中的Query_ID
```

* 常用查询参数：
  * ALL：显示所有的开销信息
  * BLOCK IO：显示块 IO 开销
  * CONTEXT SWITCHES：上下文切换开销
  * CPU：显示 CPU 开销信息
  * IPC：显示发送和接收开销信息
  * MEMORY：显示内存开销信息
  * PAGE FAULTS：显示页面错误开销信息
  * SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息
  * SWAPS：显示交换次数开销信息

* 日常开发需注意的结论：
  1. converting HEAP to MyISAM：查询结果太大，内存不够，数据往磁盘上搬了
  2. Creating tmp table：创建临时表。先拷贝数据到临时表，用完后再删除临时表
  3. Copying to tmp table on disk：把内存中临时表复制到磁盘上，危险！！！
  4. locked
  * 如果在 show profile 诊断结果中出现了以上4条结果中的任何一条，则 sql 语句需要优化

## 六、Explain

* 定义：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的

### 6.1 功能

1. 表的读取顺序
2. 哪些索引可以使用
3. 数据读取操作的操作类型
4. 哪些索引被实际使用
5. 表之间的引用
6. 每张表有多少行被物理查询

### 6.2 使用

* 语法：`Explain + SQL语句;`

#### 6.2.1 id

* 定义：select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序
* 三种情况：
  1. id 相同，执行顺序由上至下
  2. id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行
  3. id 如果相同，可以认为是一组，从上往下顺序执行
  4. 在所有组中，id 值越大，优先级越高，越先执行
* id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好

#### 6.2.2 select_type

* SIMPLE：简单的 select 查询，查询中`不包含子查询或者 UNION`
* PRIMARY：查询中若包含`任何复杂的子部分`，最外层查询则被标记为 Primary
* DERIVED：在 `FROM 列表中包含的子查询`被标记为 DERIVED（衍生），MySQL 会递归执行这些子查询，把结果放在临时表里
* SUBQUERY：在 SELECT 或 WHERE 列表中包含了`子查询`
* DEPENDENT SUBQUERY：在 SELECT 或 WHERE 列表中包含了`子查询，子查询基于外层`
* UNCACHEABLE SUBQUREY
* UNION：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为 DERIVED
* UNION RESULT：从 UNION 表获取结果的 SELECT

#### 6.2.3 table

* 显示这一行的数据是关于哪张表的

#### 6.2.4 type

* system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个可以忽略不计
* const：表示`通过索引一次就找到了`,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快
* eq_ref：唯一性索引扫描，`对于每个索引键，表中只有一条记录与之匹配`。常见于主键或唯一索引扫描
* ref：非唯一性索引扫描，`返回匹配某个单独值的所有行`。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， 它可能会找到多个符合条件的行，所以他应该属于`查找和扫描的混合体`
* range：`只检索给定范围的行`，使用一个索引来选择行
* index：出现 index 是 sql `使用了索引但是没用通过索引进行过滤`，一般是使用了覆盖索引或者是利用索引进行了排序分组
* ALL：一般来说，**至少保证查询达到 range 级别，最好能到 ref**

#### 6.2.5 possible_keys

* 显示可能应用在这张表中的索引，可以是多个
* 查询涉及到的字段上若存在索引，则被列出，但`不一定被使用`

#### 6.2.6 key

* 实际使用到的索引，null 代表没使用索引
* 查询若使用覆盖索引，则该索引仅出现在 key 列表中

#### 6.2.7 key_len

* 表示索引中使用的字节数，越小越好，显示的值为索引字段的`最大可能长度`，并非实际使用长度

#### 6.2.8 ref

* 显示索引的哪一列被使用了，最好是常量

#### 6.2.9 rows

* 根据表统计信息及索引选用情况，大致估计出找到所需的记录所需要读取的行数

#### 6.2.10 extra

* 包含不适合在其他列展示的但重要的额外信息

## 七、查询优化

### 7.1 常见索引失效

1. 全值匹配
2. 最佳左前缀法则：过滤条件要使用索引必须`按照索引建立时的顺序`，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用
3. 不要在索引列上做任何操作（计算、函数、（自动or手动）类型转换），否则会导致`索引失效`而转向`全表扫描`
4. 存储引擎不能使用索引中范围条件右边的列
5. mysql 在使用`不等于`（!= 或者 <>）的时候，`索引失效`会导致`全表扫描`
6. `is not null` 也无法使用索引，但是 `is null` 是可以使用索引的
7. like 以通配符、下划线开头（'`%`abc...','`_`abc...'），mysql `索引失效`会变成`全表扫描`
8. 字符串`不加单引号`索引失效

### 7.2 优化建议

1. 对于单键索引，尽量选择针对当前 query 过滤性更好的索引
2. 在选择组合索引的时候，当前 query 中`过滤性最好的字段`在索引字段顺序中，位置越`靠前`越好
3. 在选择组合索引的时候，尽量选择可以能够包含当前 query 中的 where 字句中更多字段的索引
4. 在选择组合索引的时候，如果某个字段可能出现`范围查询`时，尽量把这个字段放在索引次序的`最后面`
5. 书写 sql 语句时，尽量`避免造成索引失效`的情况

### 7.3 关联查询优化

1. 保证被驱动表的 join 字段已经被索引
2. left join 时，选择`小表`作为驱动表，大表作为被驱动表
3. inner join 时，mysql 会自己帮你把小结果集的表选为驱动表
4. 子查询尽量不要放在`被驱动表`，有可能使用不到索引
5. 能够直接多表关联的尽量直接关联，`不用子查询`（谓词下推）

### 7.4 子查询优化

* 子查询中尽量不要使用 not in 或者 not exists

### 7.5 排序分组优化

* ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序
* 当范围条件和group by 或者 order by  的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然
* 如果不在索引列上，filesort有两种算法： mysql就要启动双路排序和单路排序
		定义
			双路排序
				两次扫描磁盘，最终得到数据
					读取行指针和orderby列，对他们进行排序
					扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出
			单路排序
				从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了
		优化
			增大sort_buffer_size参数的设置
			增大max_length_for_sort_data参数的设置
			减少select 后面的查询的字段。